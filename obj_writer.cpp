#include "obj_writer.h"
#include <iostream>
#include <fstream>

OBJWriter::OBJWriter() : generateGround(true) {}

bool OBJWriter::writeToOBJ(const std::string& filename,
    const std::vector<std::vector<double>>& depthData,
    double scale) {
    if (depthData.empty()) {
        std::cerr << "Минимальная глубина" << std::endl;
        return false;
    }

    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Максимальная глубина " << filename << std::endl;
        return false;
    }

    writeHeader(file);
    writeVertices(file, depthData, scale);
    writeFaces(file, depthData);

    file.close();

    return true;
}

void OBJWriter::setGenerateGround(bool generate) {
    generateGround = generate;
}

void OBJWriter::writeHeader(std::ofstream& file) {
    file << "# 3D Model from Depth Map\n";
    file << "# Generated by Lab3 \n";
    file << "# Format: Wavefront OBJ (ASCII)\n\n";
}

void OBJWriter::writeVertices(std::ofstream& file,
    const std::vector<std::vector<double>>& depthData,
    double scale) {
    int height = depthData.size();
    int width = depthData[0].size();

    file << "# Вершины\n";
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            double depth = depthData[i][j];
            double x = (j - width / 2.0) * scale;
            double y = depth * scale;  
            double z = (i - height / 2.0) * scale;
            file << "v " << x << " " << y << " " << z << "\n";
        }
    }
    file << "\n";
}

void OBJWriter::writeFaces(std::ofstream& file,
    const std::vector<std::vector<double>>& depthData) {
    int height = static_cast<int>(depthData.size());
    if (height < 2) return;

    int width = static_cast<int>(depthData[0].size());
    if (width < 2) return;

    file << "# Faces\n";
    int faceCount = 0;

    for (int i = 0; i < height - 1; i++) {
        for (int j = 0; j < width - 1; j++) {
            
            bool valid = true;
            for (int di = 0; di <= 1; di++) {
                for (int dj = 0; dj <= 1; dj++) {
                    if (depthData[i + di][j + dj] <= 0.0) {
                        valid = false;
                        break;
                    }
                }
                if (!valid) break;
            }

            if (!valid) continue;

            // Индексы вершин 
            int v1 = i * width + j + 1;
            int v2 = i * width + j + 2;
            int v3 = (i + 1) * width + j + 1;
            int v4 = (i + 1) * width + j + 2;

            // Создаем два треугольника
            file << "f " << v1 << " " << v2 << " " << v3 << "\n";
            file << "f " << v2 << " " << v4 << " " << v3 << "\n";

            faceCount += 2;
        }
    }

    std::cout << "Создано " << faceCount << " треугольников" << std::endl;
}